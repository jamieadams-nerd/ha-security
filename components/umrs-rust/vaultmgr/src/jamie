use serde::Deserialize;
use std::collections::HashMap;
use std::fs::File;
use std::io::BufReader;
use std::path::Path;

#[derive(Debug, Deserialize)]
pub struct Catalog {
    pub labels: HashMap<String, Label>,
    pub markings: HashMap<String, Marking>,
}

pub fn load_catalog<P: AsRef<Path>>(path: P) -> Result<Catalog, String> {
    let path_ref = path.as_ref();

    let file = File::open(path_ref)
        .map_err(|e| format!("Failed to open {}: {}", path_ref.display(), e))?;

    let reader = BufReader::new(file);

    serde_json::from_reader(reader).map_err(|e| {
        format!("Failed to parse JSON {}: {}", path_ref.display(), e)
    })
}

impl Catalog {
    // Lookup a marking by its JSON key (e.g. "CUI//LEI/JUV").
    pub fn marking(&self, key: &str) -> Option<&Marking> {
        self.markings.get(key)
    }

    // Iterate all markings (key, marking struct).
    pub fn iter_markings(&self) -> impl Iterator<Item = (&String, &Marking)> {
        self.markings.iter()
    }

    // Return all direct children of a marking key.
    //
    // Example:
    // "CUI//LEI" â†’ iterable of LEI subcategories
    pub fn marking_children<'a>(
        &'a self,
        parent_key: &str,
    ) -> impl Iterator<Item = (&'a String, &'a Marking)> {
        // Extract the last segment of the key
        let parent_segment =
            parent_key.rsplit("//").next().unwrap_or(parent_key);

        self.markings
            .iter()
            .filter(move |(_, m)| m.parent_group == parent_segment)
    }
}
