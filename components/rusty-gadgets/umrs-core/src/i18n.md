Excellent — this is the right follow-through question. Let’s wire it cleanly and concretely.

You now have a dual-mode i18n module inside **umrs-core** with:

* `init(domain)`
* `tr(msgid)`
* `tr_core(msgid)`

Your CLI only needs to do **one thing** at startup.

---

# Step 1 — Decide CLI domain name

Pick the gettext domain for the tool.

Examples:

```
vaultmgr
umrs-state
cui-labels
robotgen
```

We’ll use `vaultmgr` in examples.

---

# Step 2 — Initialize i18n at program start

**File to edit:**

```
vaultmgr/src/main.rs
```

Add near the top (after args parsing is fine, but before output):

```rust
use umrs_core::i18n;
```

Then inside `main()`:

```rust
fn main() {
    // Initialize CLI text domain
    i18n::init("vaultmgr");

    println!("{}", i18n::tr("Vault manager starting"));
}
```

That’s it for initialization.

---

# Step 3 — Use translations in CLI code

Anywhere in the CLI:

```rust
println!("{}", i18n::tr("Creating vault directory"));
println!("{}", i18n::tr("Vault created successfully"));
println!("{}", i18n::tr("Operation failed"));
```

These resolve via:

```
/usr/share/locale/<lang>/LC_MESSAGES/vaultmgr.mo
```

---

# Step 4 — Library messages (automatic)

Inside `umrs-core` modules you already use:

```rust
tr_core("Audit event emitted")
```

These resolve via:

```
/usr/share/locale/<lang>/LC_MESSAGES/umrs-core.mo
```

CLI does nothing special to enable this — your earlier `init()` + `ensure_locale()` covers it.

---

# Runtime behavior

Example execution:

```
LANG=fr_FR.UTF-8 vaultmgr
```

Lookup flow:

| Call        | Domain    | Catalog      |
| ----------- | --------- | ------------ |
| `tr()`      | vaultmgr  | vaultmgr.mo  |
| `tr_core()` | umrs-core | umrs-core.mo |

Simultaneous. No collision.

---

# Minimal working example

**vaultmgr/src/main.rs**

```rust
use umrs_core::i18n;

fn main() {
    i18n::init("vaultmgr");

    println!("{}", i18n::tr("Vault manager starting"));

    // Library call example
    println!("{}", i18n::tr_core("Audit event emitted"));
}
```

---

# Step 5 — Install catalogs

System layout must include both domains:

```
/usr/share/locale/fr_FR/LC_MESSAGES/vaultmgr.mo
/usr/share/locale/fr_FR/LC_MESSAGES/umrs-core.mo
```

If one is missing → fallback to English msgid.

---

# Important operational rule

Only the CLI calls:

```
i18n::init()
```

Libraries never call it.

Why:

* Prevents domain override
* Prevents locale mutation
* Keeps embedding safe

Your current design follows this correctly.

---

# Optional ergonomic alias (CLI side)

If you want shorter calls:

```rust
use umrs_core::i18n::tr;

println!("{}", tr("Vault created"));
```

Purely cosmetic.

---

# Summary

| Task                   | Location            |
| ---------------------- | ------------------- |
| Initialize domain      | CLI `main()`        |
| Translate CLI text     | `tr()`              |
| Translate library text | `tr_core()`         |
| Locale safety          | `ensure_locale()`   |
| Catalog install        | `/usr/share/locale` |

---

You’re now running a **multi-domain gettext architecture**:

* Application domain
* Core library domain
* Shared locale
* Independent catalogs

Clean, deterministic, and packaging-friendly — exactly what you want for UMRS tooling.

