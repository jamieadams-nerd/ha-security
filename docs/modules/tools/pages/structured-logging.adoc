UMRS Structured Activity Logging Overview

UMRS tools use the system logging stack already provided by Red Hat Enterprise Linux rather than implementing custom log files or ad-hoc serialization. Each tool emits semantic, machine-parseable activity events using the standard syslog interface, allowing the operating system to handle identity, security context, storage, and retention in a consistent and auditable way.

Event Emission (syslog / logger)

UMRS tools emit log events using either:

The syslog API directly (for example, via libc::syslog in Rust), or

The standard logger utility (logger -t umrs-tool -- "key=value ...")

In both cases, the emitted message contains UMRS semantic fields encoded as space-separated key=value pairs. Values that may contain spaces are enclosed in single quotes. Example:

action=sanitize result=SUCCESS file=/path/to/file detail='second pass complete'

Each message is tagged with a stable identifier using the syslog “program name” (for example, umrs-shred, umrs-sign). This identifier is the primary routing key for UMRS logging.

At this stage, UMRS tools are intentionally simple:

They emit meaning (what happened)

They do not manage storage, rotation, or formatting

They rely on the OS logging infrastructure for context and durability

journald as the Authoritative Event Store

All syslog messages are first ingested by systemd-journald. journald automatically records authoritative metadata for each event, including:

UID, GID, PID

Executable path

SELinux context

Timestamp and boot ID

Syslog facility and priority

UMRS does not override journald defaults or retention policy. journald remains the authoritative source of truth for system activity and forensics.

Routing UMRS Events with rsyslog

rsyslog is used as an export and transformation layer, not as the primary store.

A dedicated rsyslog rule matches any event whose program name starts with “umrs-”. These events are:

Written to a dedicated UMRS activity log file

Converted into JSON Lines (one JSON object per line)

Prevented from propagating into /var/log/messages

What “rsyslog rule” means in this context

When the documentation refers to an “rsyslog rule,” it is specifically referring to the configuration contained in:

/etc/rsyslog.d/10-umrs-activity-json.conf

That file contains two distinct but related things:

The template
The template defines how matching log events are rendered.

In your case, the template named umrsJsonLine tells rsyslog:

Which fields to extract from the event

How to serialize them

That the output should be valid JSON

That each event should be written as a single JSON object per line (JSONL)

This is the formatting logic.

The rule
The rule defines which events the template applies to and what to do with them.

This is the conditional block:

if ($programname startswith "umrs-") then {
action(type="omfile"
file="/var/log/umrs-activity.jsonl"
template="umrsJsonLine")
stop
}

This rule says:

Match any log entry whose program name begins with “umrs-”

Write it to /var/log/umrs-activity.jsonl using the umrsJsonLine template

Stop further processing so it does not also go to /var/log/messages

So yes — the same file contains:

the template (format)

the rule (routing + control flow)

Why this structure is intentional and correct

rsyslog’s design deliberately separates:

“What does the output look like?” (template)

“Which messages go where?” (rule)

Keeping both in the same UMRS-specific file:

makes the configuration self-contained

avoids scattering UMRS logic across multiple files

makes review and auditing easier

allows the file to be enabled or removed cleanly

Why the file name starts with “10-”

The numeric prefix controls load order.

Files in /etc/rsyslog.d are processed in lexical order

“10-” ensures the UMRS rule runs early

The explicit stop ensures that once matched, UMRS messages do not fall through to later rules

This makes the behavior predictable and easy to reason about.

One sentence you can add to the docs (if you want)

You could add something like this:

“UMRS log routing is implemented via a dedicated rsyslog configuration file (10-umrs-activity-json.conf) which defines both the JSON output template and the routing rule that directs umrs-* tagged events into the UMRS activity log.”

This ensures UMRS activity is isolated, structured, and easy to consume, while leaving the rest of the system logging unchanged.

JSON Lines Output (umrs-activity.jsonl)

UMRS activity is written to:

/var/log/umrs-activity.jsonl

Each line in this file is a complete JSON object generated by rsyslog using its native jsonf support. The JSON includes:

Timestamp

Hostname

Program name (UMRS tool)

PID

Syslog severity and facility

Message (the original UMRS key=value semantic payload)

Optional SELinux context (when available from journald)

Because JSON Lines is append-only and line-delimited:

The file can be tailed efficiently

Partial writes do not corrupt unrelated entries

Consumers can read incrementally without loading the entire file

Reading and Parsing the Log

Consumers (such as a UMRS log viewer) read the file line-by-line and parse each line as JSON. Each line produces a dictionary/map representing a single event.

The MESSAGE field contains UMRS semantic data (action, result, detail, file, etc.) and can be further parsed using shell-style tokenization (for example, shlex.split in Python) to safely handle quoted values.

The viewer combines:

Semantic meaning from the MESSAGE payload

Authoritative metadata from journald-derived fields

Tool-specific conventions (action/result) to generate clear, human-readable descriptions

Separation of Responsibilities

This design intentionally separates concerns:

UMRS tools: emit semantic events only

journald: authoritative storage, identity, SELinux context

rsyslog: filtering, JSON formatting, file output

Viewer: interpretation, correlation, human-readable presentation

No component duplicates another’s role, and each layer can evolve independently.

Outcome

The result is a robust, auditable, and easily demonstrable structured logging pipeline using only standard RHEL components. UMRS gains machine-parseable activity logs suitable for automation and GUI consumption, while retaining compatibility with system forensics and enterprise logging practices.
