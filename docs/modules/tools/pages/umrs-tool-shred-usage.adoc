Understood. Below is a **complete rewrite**, integrated and clarified, with **explicit explanation of journald and rsyslog JSONL logging**, written for *regular users*, in **raw AsciiDoc**, ready to paste.

No smart quotes. No Markdown. No UI formatting.

---

= Using umrs-shred
Jamie L. Adams

== Overview

The `umrs-shred` tool is a UMRS helper utility for best-effort file-level sanitization of individual files prior to removal. It is intended for Controlled Unclassified Information (CUI) handling on unclassified systems, where the objective is risk reduction, procedural correctness, and auditability rather than forensic-proof data destruction.

In practical use, `umrs-shred` wraps the underlying overwrite mechanism (GNU `shred`) using fixed UMRS-approved parameters, adds strict safety checks to prevent dangerous misuse, and records sanitization activity as auditable security events. These events are captured by the system logging infrastructure and exported in structured form for later review.

UMRS treats overwrite-based deletion as a supplemental control. Strong assurance for data-at-rest sanitization comes from full-disk encryption and cryptographic key destruction. `umrs-shred` exists to reduce the likelihood of casual recovery and to demonstrate intentional, documented sanitization actions.

== Typical Usage

For regular users, `umrs-shred` is invoked much like a file-removal command, but only for regular files:

---

## umrs-shred /path/to/file

Multiple files may be specified in a single invocation:

---

## umrs-shred /path/to/file1 /path/to/file2

Shell globbing is expanded by the shell before execution, so patterns such as the following are also valid:

---

## umrs-shred /path/to/*.txt

In UMRS workflows, `umrs-shred` is often best used inside cleanup scripts that remove temporary CUI artifacts as part of a repeatable operational procedure. Using the helper utility ensures consistent behavior and centralized logging, which is preferable to ad hoc command usage.

== Safety Checks and Validation

Before performing any sanitization, `umrs-shred` validates each target and refuses to operate if the target fails a safety check. These checks are intentionally strict and conservative.

The tool verifies that the path is not empty, that the target exists, that the target is not a symbolic link, and that the target is a regular file. It will not operate on directories, block devices, character devices, FIFOs, or sockets.

If the tool is invoked by a non-root user, it additionally verifies that the file is writable by the caller. If any check fails, the operation is refused. This behavior is deliberate and is intended to prevent accidental destructive actions and to ensure that sanitization claims are unambiguous.

== Advisory Locking

`umrs-shred` uses an advisory lock to prevent overlapping executions. This locking mechanism is not a permission control and is not a security boundary. Its purpose is operational clarity and safety.

When advisory locking is available, only one instance of `umrs-shred` is allowed to run at a time. If another instance is already active, the tool exits early rather than producing interleaved operations and interleaved log entries that can be difficult to interpret.

This behavior is especially important when `umrs-shred` is used in automated cleanup scripts, cron jobs, or repeated interactive workflows.

== What Happens During Sanitization

Once a target passes validation and the advisory lock is acquired, `umrs-shred` invokes the underlying overwrite mechanism using a fixed UMRS policy. This policy includes a defined number of overwrite passes, a final zeroing pass, and removal of the file after overwriting.

These parameters are intentionally not user-configurable. Removing discretion reduces the risk of unsafe or misleading usage patterns and ensures that sanitization behavior is consistent across systems and operators.

UMRS explicitly documents that file-level overwriting, even when performed through `umrs-shred`, cannot guarantee complete removal of all residual data on modern journaling filesystems, copy-on-write filesystems, or solid-state storage devices. The tool is designed for best-effort, file-level risk reduction appropriate to CUI handling.

== Logging and Audit Trail

A key feature of `umrs-shred` is that sanitization actions are treated as security-relevant events and are logged centrally.

When `umrs-shred` runs, it emits structured log messages using the system logging interface. These messages are first ingested by systemd-journald, which acts as the authoritative event store. journald automatically associates each event with system metadata such as timestamp, process ID, user identity, and SELinux context.

From journald, UMRS-specific log entries are routed by rsyslog. A dedicated rsyslog configuration matches events generated by UMRS tools (identified by the `umrs-` program name prefix) and writes them to a separate activity log file using a JSON template.

The resulting log file is written in JSON Lines format at:

---

## /var/log/umrs-activity.jsonl

Each line in this file is a complete JSON object representing a single sanitization event. This format allows the file to be tailed efficiently and processed incrementally by scripts or graphical viewers.

== Types of Log Entries You Will See

For each file processed, `umrs-shred` normally produces at least two log entries.

A BEGIN entry indicates that the tool accepted the request and is starting sanitization for a specific file. A SUCCESS entry indicates that sanitization completed successfully. If validation fails or the overwrite operation encounters an error, a FAIL entry is recorded instead.

Each log entry includes structured fields such as the tool name (`umrs-shred`), the actor who invoked the tool, numeric user identifiers, the target file path, the action being performed, the result (BEGIN, SUCCESS, or FAIL), and a short detail string describing the reason or outcome.

Because these events are structured, a viewer can easily present a human-readable narrative such as "jadams sanitized /path/to/file successfully" while preserving detailed evidence for auditing and compliance.

== Practical Guidance for Regular Users

`umrs-shred` is safest and most effective when used on specific, known files rather than broad or ambiguous paths. For scripted cleanup, target well-defined working directories that contain temporary CUI artifacts and ensure those directories are protected by appropriate permissions and, where applicable, SELinux policy.

If `umrs-shred` refuses to operate on a target, treat that refusal as a safety feature rather than an error. The tool is designed to fail closed rather than guess.

== Summary

`umrs-shred` provides a controlled, auditable, best-effort file-level sanitization capability appropriate for CUI handling. It enforces strict safety validation, uses advisory locking to prevent overlapping executions, applies consistent overwrite parameters, and records structured BEGIN, SUCCESS, and FAIL events to journald and the UMRS JSON Lines activity log. This approach supports repeatable operational procedures, accountability, and alignment with UMRS logging and audit practices without overstating technical guarantees.


