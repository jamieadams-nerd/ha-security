= UMRS Shred Wrapper
Jamie L. Adams


./umrs-shred /absolute/path/to/junk



Advisory Locking:

umrs-shred uses a best-effort advisory lock to serialize destructive operations and preserve a clear, unambiguous audit trail. While concurrent sanitization is not inherently unsafe, overlapping runs can produce interleaved log messages, ambiguous attribution, and confusing operational timelines. Locking ensures that each invocation completes as a discrete, auditable event. Lock files are intentionally placed in per-user runtime locations when running unprivileged (/run/user/<uid>/umrs) and in a dedicated system runtime directory when running as root (/run/umrs). This avoids cross-user interference, respects privilege boundaries, and prevents one user’s activity from blocking another’s authorized work. The lock is advisory, short-lived, automatically released on exit or signal, and is used for operational clarity and auditability rather than as a security control.




Produces two log entries:


When you do not specify a facility or priority, logger uses defaults:

• Facility: user
• Priority: notice

So your current calls effectively mean:

facility=user
priority=notice
tag=umrs-shred



A begin task and then a result message which could be success or fail.

The detail= field is a free field to explain why the action was done. Our choice.
[source,log]
====
Dec 19 21:23:19 localhost umrs-shred[414011]: ts_utc=2025-12-20T02:23:19Z level=INFO tool=umrs-shred actor=jadams uid=1000 loginuid=1000 selinux=unconfined_u:unconfined_r:unconfined_t:SystemLow-SystemHigh action=sanitize result=BEGIN file=/home/jadams/Development/umrs-project/components/umrs-shred/junk detail=requested

Dec 19 21:23:19 localhost umrs-shred[414025]: ts_utc=2025-12-20T02:23:19Z level=INFO tool=umrs-shred actor=jadams uid=1000 loginuid=1000 selinux=unconfined_u:unconfined_r:unconfined_t:SystemLow-SystemHigh action=sanitize result=SUCCESS file=/home/jadams/Development/umrs-project/components/umrs-shred/junk detail=shred_completed
----



 1810  logger -t umrs-test -- 'action=test result=BEGIN detail=requested'
 1811  logger -t umrs-test -- 'action=test result=SUCCESS detail=ok'
 1812  journalctl -t umrs-test -n 5 -o json
 1813  journalctl -t umrs-test -n 5 -o json > test.log


Exactly. What you just saw is journald doing exactly what it is designed to do. Let me answer each part cleanly and precisely.

Is that data stored in journald?
Yes.

When you used logger, the messages were written into systemd-journald’s journal.
That journal is the authoritative store at that moment.

Whether it is:

memory-only, or

persisted on disk

depends on journald configuration (see below).

Was it forwarded to rsyslog?
On RHEL, yes by default, but with nuance.

Default RHEL behavior:

journald receives the message first

journald forwards to rsyslog via the systemd journal socket

rsyslog then decides what to do with it (write to /var/log/messages, drop it, route it, etc.)

So the pipeline is:

logger
→ journald
→ rsyslog (if enabled and configured)
→ traditional log files (optional)

You can confirm rsyslog is receiving UMRS messages with:
journalctl -t umrs-shred -n 5
and
grep umrs-shred /var/log/messages

If you see it in both, forwarding is happening.

Important:
Even if rsyslog is disabled or filtered, journald still keeps the event (subject to retention).

How long is data accessible via journalctl?
This depends on journald storage mode and limits.

Check current journald mode:
grep ^Storage= /etc/systemd/journald.conf

Common cases:

A) Storage=volatile

Logs live in memory only

Lost on reboot

Retained until memory pressure or size limit

B) Storage=persistent

Logs stored under /var/log/journal/

Survive reboots

Retained until size/time limits are reached

On most RHEL systems:

persistent storage is enabled if /var/log/journal exists

Check:
ls -ld /var/log/journal

If it exists, logs are persistent.

What controls retention time and size?
journald uses size-based retention, not time-based by default.

Key settings (journald.conf):

SystemMaxUse=

SystemKeepFree=

RuntimeMaxUse=

MaxRetentionSec= (optional, newer systems)

Example:
SystemMaxUse=4G

Meaning:

journald keeps logs until total size reaches 4 GB

oldest entries are dropped first

To see current usage:
journalctl --disk-usage

Example output:
Archived and active journals take up 1.2G in the file system.

How far back can journalctl see?
As far back as:

the oldest retained journal file, and

the current boot (unless you specify otherwise)

Examples:

Current boot only:
journalctl -b

Previous boot:
journalctl -b -1

All boots (until retention):
journalctl

Time-bounded:
journalctl --since "2025-12-19 20:00" --until "2025-12-19 22:00"

This is extremely useful for forensic timelines.

How this fits your UMRS design (this is the important part)
You now have a clean separation of responsibilities:

journald:

authoritative event store

identity, SELinux, PID, executable, unit

retention, boot boundaries, timestamps

rsyslog (later):

filtered export

JSON Lines files

permissions, rotation

long-term artifacts for viewers and tooling

UMRS tools:

emit semantic events only

do not manage storage or rotation

remain simple and auditable

Your JSONL experiment via journalctl -o json is effectively a preview of what rsyslog will formalize later.

Practical takeaway
Right now:

Your events are safely in journald

You can query them reliably

You can prototype a viewer using journalctl JSON output

Later:

You add rsyslog rules to create umrs-activity.jsonl

The viewer tails that file for speed

journalctl remains the forensic backstop

Nothing you did is throwaway work.

If you want, next we can:

check your journald.conf and explain exactly how long logs will live

write a minimal rsyslog JSON template for umrs-* identifiers

decide whether UMRS wants persistent journald as a documented requirement

You are on very solid ground here.
On RHEL 10, /etc/systemd/journald.conf does not exist by default. journald is running entirely on compiled-in defaults, optionally modified by drop-in snippets. This is intentional systemd behavior, not a misconfiguration.

Here is how it works, concretely.

Why the file is missing
systemd treats journald.conf as optional. If it is absent:

journald uses built-in defaults

no error is logged

the service runs normally

Red Hat intentionally does not ship a default config file so that:

the effective configuration is simpler

overrides are explicit

changes are auditable

Where configuration actually comes from (precedence order)

Compiled defaults (always present)

Drop-ins:
/etc/systemd/journald.conf.d/*.conf

Main file:
/etc/systemd/journald.conf (only if you create it)

Best practice on RHEL 10 is drop-ins, not editing or creating the monolithic file.

How to see what journald is actually doing right now
This is the key command you want:

systemctl show systemd-journald | grep -E 'Storage=|SystemMaxUse=|RuntimeMaxUse=|MaxRetentionSec='

That shows the effective values, even when no config file exists.

To check whether logs are persistent:

ls -ld /var/log/journal

If it exists → persistent storage (survives reboot)

If it does not → volatile (memory only)

To see how much history you currently have:

journalctl --disk-usage

How long logs are retained
By default, journald uses size-based retention, not time-based:

Logs are kept until disk usage reaches a limit

Oldest entries are dropped first

Defaults are conservative and system-safe

Unless you set MaxRetentionSec=, there is no fixed time window — retention depends on volume.

If you later want to make journald behavior explicit (recommended for UMRS, but not required yet)

Do not create /etc/systemd/journald.conf.

Instead, create a drop-in:

sudo mkdir -p /etc/systemd/journald.conf.d

sudo tee /etc/systemd/journald.conf.d/umrs.conf >/dev/null <<'EOF'
[Journal]
Storage=persistent
SystemMaxUse=2G
EOF

Then:

sudo systemctl restart systemd-journald

This gives you:

persistent logs

a bounded size

a clearly documented UMRS override

Why this is good for UMRS
Your current design aligns perfectly with RHEL 10 expectations:

UMRS tools emit semantic events

journald stores authoritative context

rsyslog (later) exports JSONL

viewer merges meaning + metadata

The absence of journald.conf is not a gap — it is the default, modern systemd model.


Yes. You can do exactly that with rsyslog, without changing journald retention at all.

Goal

Anything with SYSLOG_IDENTIFIER / program name starting with umrs- goes to /var/log/umrs-activity.jsonl in JSON Lines format

Those umrs-* entries do NOT also go to /var/log/messages

How it works (high level)

logger -> journald (unchanged)

rsyslog reads from journald

rsyslog matches programname “umrs-*”

rsyslog writes JSON to /var/log/umrs-activity.jsonl

rsyslog stops further processing for those messages so they do not hit /var/log/messages

Step 1: Create the destination file and set permissions
sudo touch /var/log/umrs-activity.jsonl
sudo chown root:root /var/log/umrs-activity.jsonl
sudo chmod 0640 /var/log/umrs-activity.jsonl
sudo restorecon -v /var/log/umrs-activity.jsonl || true

Step 2: Add an rsyslog rule that routes umrs-* to JSONL and stops propagation
Create this file:

sudo tee /etc/rsyslog.d/10-umrs-activity-json.conf >/dev/null <<'EOF'

UMRS routing: write umrs-* identifiers to a dedicated JSON Lines activity log and stop further processing.
This avoids duplicating UMRS events into /var/log/messages.

template(name="umrsJsonLine" type="list") {
constant(value="{")
constant(value=""ts":"") property(name="timereported" dateFormat="rfc3339")
constant(value="","host":") property(name="hostname" format="json")
constant(value=","program":") property(name="programname" format="json")
constant(value=","pid":"") property(name="procid")
constant(value="","severity":"") property(name="syslogseverity-text")
constant(value="","facility":"") property(name="syslogfacility-text")
constant(value="","message":") property(name="msg" format="json")
constant(value="}\n")
}

if ($programname startswith "umrs-") then {
action(type="omfile"
file="/var/log/umrs-activity.jsonl"
template="umrsJsonLine")
stop
}
EOF

Notes

programname is the syslog tag (what you set with logger -t umrs-shred, etc.)

stop is what prevents it from also going to /var/log/messages

Step 3: Restart rsyslog
sudo systemctl restart rsyslog

Step 4: Test
Send a couple of test entries:

logger -t umrs-test -- 'action=test result=BEGIN detail=requested'
logger -t umrs-test -- 'action=test result=SUCCESS detail=ok'

Now verify they landed in the JSONL file:

sudo tail -n 10 /var/log/umrs-activity.jsonl

And verify they did NOT land in /var/log/messages:

sudo tail -n 50 /var/log/messages | grep umrs-test || echo "No umrs-test entries in /var/log/messages"

Step 5 (recommended): Add logrotate so the JSONL file does not grow forever
sudo tee /etc/logrotate.d/umrs-activity >/dev/null <<'EOF'
/var/log/umrs-activity.jsonl {
daily
rotate 14
missingok
notifempty
compress
delaycompress
create 0640 root root
sharedscripts
postrotate
/bin/systemctl kill -s HUP rsyslog.service >/dev/null 2>&1 || true
endscript
}
EOF

That should give you exactly what you want: journald keeps its defaults, but UMRS events are exported as JSONL to a dedicated file and kept out of /var/log/messages.

If you want the JSONL to include specific journald metadata (like SELinux context) in the JSON file, say so and I’ll give you the RHEL10-friendly way to add those fields (it depends on whether rsyslog is ingesting the full journal fields or only the syslog view).

What you saw “disappear” is exactly the boundary between “classic syslog” and “journald metadata”.

Why the SELinux context (and other journald fields) vanished

journald stores lots of extra metadata fields (including SELinux context) that are NOT part of the traditional syslog message header.

rsyslog can receive messages in two common ways:

the classic syslog stream (imuxsock / syslog socket view) -> you only get facility/severity/program/pid/message, and you lose journald-only fields like SELinux context

the journal database (imjournal) -> you can access journald’s structured fields like _SELINUX_CONTEXT

SELinux context is specifically called out as journald metadata that is absent in a syslog header. 
Log Analysis | Log Monitoring by Loggly

So, in the rsyslog config I gave you, the JSON template only included the classic syslog properties. That’s why you got a clean JSON line, but not the journald extras.

You have two good choices (pick the one that matches your viewer plan)

Choice A (simplest, and aligns with your earlier realization)

Keep the JSONL file as a fast “semantic activity stream” (message + program + timestamps).

When you need SELinux context and other metadata, query journald directly in the viewer (or via journalctl JSON) and merge it at display time.
This avoids complexity and keeps rsyslog fast.

Choice B (put journald metadata into the JSONL file)
To get _SELINUX_CONTEXT and similar fields into /var/log/umrs-activity.jsonl, rsyslog must read from journald’s structured source (imjournal). imjournal is specifically the rsyslog module that imports structured data from the systemd journal. 
Rsyslog

How to tell what you currently have (quick test)
After you put your umrs-* routing in place, add selinux_context to the JSON template using this property:

property(name="$!_SELINUX_CONTEXT" format="json")

If it always comes out empty or null, your rsyslog input path is not delivering structured journal fields (you’re on the classic syslog path).

Minimal change to include SELinux context in the JSONL template (works only if imjournal is providing it)
Edit your template and add a field like this:

,"selinux_context": property(name="$!_SELINUX_CONTEXT" format="json")

For example, inside your existing umrsJsonLine template, add one line before message:

constant(value=","selinux_context":") property(name="$!_SELINUX_CONTEXT" format="json")

If you need to switch rsyslog to read the structured journal (imjournal)
This is the part that depends on your current rsyslog config. Some RHEL setups already use imjournal; others use the syslog socket view.

The concept is:

ensure rsyslog loads imjournal and has an input(type="imjournal")

then the journal fields show up as structured properties (like $!_SELINUX_CONTEXT)

This “journal fields become accessible to rsyslog” approach is commonly described as imjournal exposing fields you can reference in config. 
Stack Overflow

Important note: imjournal reads the journal database and is heavier than the classic syslog socket path; rsyslog itself recommends using it only if you need the structured data. 
Rsyslog

A practical UMRS recommendation
Given you already decided “the script doesn’t need to log selinux context because journald has it”, the cleanest UMRS architecture is:

JSONL file: semantic UMRS event stream (tool/action/result/object/detail), optimized for speed and tailing

Viewer: optionally enriches display with journald metadata (SELinux context, exe, unit, etc.) by looking up the event in journald when needed

If you still want SELinux context in the JSONL file, say so and I will give you a complete rsyslog config that:

guarantees imjournal input is enabled correctly

writes umrs-* to /var/log/umrs-activity.jsonl in JSONL

stops propagation so it does not go to /var/log/messages

includes selinux context (and optionally _EXE, _SYSTEMD_UNIT, _UID, _PID) when present

And I’ll keep it consistent with your “do not change journald retention defaults” requirement.



sudo tail -n 5 /var/log/umrs-activity.jsonl 
{"ts":"2025-12-20T03:55:54.950121-05:00", "host":"localhost", "program":"umrs-test", "pid":"456486", "severity":"notice", "facility":"user", "selinux_context":"unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023", "message":"action=test result=SUCCESS detail=ok", 
}


